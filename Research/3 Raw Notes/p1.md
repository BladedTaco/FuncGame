- the gameplay seems simple enough
- it will take time ot understand what everything does

- first checked the controls
- connected the LT the wrong way around
- easily flipped it around once the mistake aws realisec
- passed test after this

- sequence 2
- "has to be unlocked before I can hook it up"
    - mimic
- Connected up minic to unlock it
- is that juts adding 2
    - on LT
- misunderstood LT as add
- fixed it easily

- haskell
- picked up that its a maybe
- the mimic is a maybe
    - reasoning: maybe is just something or nothing
- dice is a value
- the coin is the maybe part
    - the just part
- identified less than function
    - iconography shows stat to bottom bit, saying its important
    - but botha re equally important
    - the star is what comparisons are based off of, but I couldnt tell you exactly what it is.
    - I could understand tis is a LT funciton and its comparing against the bottom one, but wouldnt know that working backwards.
 - maybe
    - tick is maybe
    - cross is nothing

- identified another less than function
    - corroborated when connected input and saw it changing
- thinks hide is a teleport
- fixed LT ordering again

- recognises the maybe
    - realises it outputs just 0

- hooks up position to LT
    - so they can see what happens when its lways 0
    - hooks up to the position maybe
    - explorators
- solves it in discrete actions/steps

- set the thieves position (we need to)
    - needs the maybe
    - reasses the situatino to find out what is wrong

- figures put the key very quick once connected two different values
- clicks on maybe and find it can connect to fmap
- 

- starts the same as the last level
- knowing how the last level was solved does help in I know what I did to solve the last level.
    - puts me on the path to solce this one.
    - I Need to teleport out and not be in the red x's

- struggles to figure out const
    - symbology seems unclear?
    - 


- const puts the value into the chest using the flask

- triple flask instead of just single flask
- puts the function into the maybe, and thinks its not helpful intiially
- is unsure what the triple flask adds compared to the single flask
- once connected the maybe to the apply applicative understood it fast.
    - connected funciton in maybe ,connected to output

- takes two inputs and returns one input, lifta2
    - connects tow inputs really fast
    - connected 

- lifta2 connects to apply as one has 3 inputs, one has 2 inputs
    - so it combines the two inputs togeher
    - it applies the function to the input and the output would be the function in the input
    - it has a very similar concept, but I assume this is conditional
    - one input as a condition input
    - if one input is bad, then it wont output anyhting.

- understands the key metaphor now


- now there is the moving crosses, and I need to dodge those two
    - you can get the cross column position from the funciton
    - cross output is very useful in solving this
         - make sure thief avvoids the crosses.

- now that they see the LT, EQ and MAX together, they understand the differen comparisons
     - and function 
    - instantly sees it as max wheh connecting inputs
    - connectes bools and sees its an OR for bools

- connects up with maybes quickly
    - its an equals still, but now it has a chest
    - max is the same
    - replaces connections wuickly

- quickly connects the bind with the things around it to figur eout what it does

- chain function
    - bind, monads

- understood the new things in the level fast

- "I need to play more puzzle games obvioulsy"
    - I see this as a game
    - I dont see this sa a tutorial

- I need to be the same row, the column does not matter

- subtract outputs a difference, foigure sit out fast
- solved the leel instantly after
- this is making things more low level, its breaking function downs

- solves (sign -) as sign and minus really fast
- solves - and -a and + really fast
- The maths ones are so easy, I love maths

- I was invested in the level
    - with a few more hours I could do the same wiht the earlier levels
    - it was fun because I knew I could solve it.
    - completeing levels, and accomplishment is fun


- I see the yellow bar going down and I can tell thats bad

- 1 + 1 is always equal to 2, so it will hold shield forever
- need to fix this
- solved level

- Instantly, this is a NEQ.
- this is a fork, this must line up wiht the fork input

- NEQ true is a not operator

- started off with the two bools switched, figured it out to be a not situation as the sield disappears when its right in front
- didn't connect that to the new type for a little bit

- I've lost the fork, and its split into two
- the another function, must connect the two somehow

- connected wrong, moved when the cross was right above
    - I can tell this is near what I want, but slightl wrong

- needs a better metahpor or way of explaining, since forks chaining onto forks is 
    - this is teaching if/else or control flow

- connected dx to sign dx instantly
- connected to fork construcotr next

- final level, given enough time it would be possible to solve, but not a reasonable amount of time, and it would not be fun.
- 30 minutes to an hour I could solve this

- Total time taken was around 2 hours, this may be due to a lack of experience with haskell.

- Participant has used haskell before, but not for a while, and does not remember many things.

-


- survery
- user interace and controls
    - middle click to pan is confusing at first, but learnable
    - same with right click to drag blcoks around
    