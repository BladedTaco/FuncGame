p6.md
p6.md

- level 1
- connects the inputs up instantly as shown and passes first attemtp
- follows through doing the ssme on the second phase
- solves level perfectly

- level 2

- soles the first phas equickly
- seocnd pashe connects the dce to the const to see what it doesn
- puts random things into the const to figure out what it does
- figures out to put the const into the fmap, then sees the rest from there and connects it up
- figures out how apply replaces fmap, and solces the level quickly

- could connect it direclt,y but that wouldnt hellp as then I stay still
-  see thos is a value in a function wrapper
- sees how the const is used without any inputs
- solves the level

- level 3
- sovles the first phase 
- sees LT, EQ, OR
- the values update too quickly to see properly
- its an OR because its dodging

- with the maybest quickly reocnnects it to be correct
- we are running the comparison as a function this time.

- finds the connection between the bind and the from maybe
- finds a lot of connections because the symbols match
- struggles a bit to find why we need the seocond maybe
- soles it once the second chest goes unused

- level 4

- connects Y initially, but then realises we dont care about it and switches to X vaue
- realises quickly we need to invert it from what seems to be suggested
- connects the next functions instantly, exclaimng instantly they see what to do
- final phase sees the only wiht 2 inputs is the plus, so we want to add the two somehow
- struggles a bit to realise the + -
- doesn't realise the commutation of + for a bit

- level 5

- realises the shield is always out, and this needs to be cahnged
- soles the thing quickly when using the Y positions

- phase next
 - solves the either constructor with some prompting on the bool and its not

 - phase next
 - solves it with some prompting on what we want to do
 - we split the one 3 input function into the two constructors, then combine them

 - level 6 
 - solves wuickly connecting up first phase
 - sees how the fromleft is getting the value out of the either

 - next pashe understands how we lost getting the value put and so we need to do that in a new way.

- we are using the key as a funciton again
- and I can se ehow that gets the value of the the fork

- next phase
- solved it with some prompting

- final phase

- sees the flipping function
- sees that a GT 0 is right is true and left is false
- solved the final level, with some prompting about what we need to replace

- replacing the left right boolean by calculating it
- flipping around to operated on the right

- solved

- haskell experience half a year
- games experience a lot
    - video games a lot
    - tabletop games also a lot

- since I had some functional programminge xperience I recognised some of the concepts in the blocks
    - functions in functions (currying)
    - levels of functions, taking things out of boxes, having values at different concepts of strata.

- chucking a novice programmer straight into the last level would make them quit progrmaming
- the symbols didn't make sense to me without further explanation, more explanation and showcasing of what each function does good

- levels were generally about one concept, later levels levereged earlier levels concepts and introduced one new thing to spice it up.

- if it was a fully polished game I would give it a go, but I am unsure if I would stay yet
    - being told it teaches functinoal programming it potentially detracts from this chance to paly it 

- fun?
    - it mimicked to an extent real programming where completion is rewarding, and seeing how different things connect is fun
    - it was more fun than programming, and was fun at points
    - a hint system would make it a lot more fun and reduce frustration
- best level?
    - level 3 was the most interesting, because there were two things I had to account for rather than just the one
    - two adjacent but connected issues. Solving one issue helps with solving another issue
    - it transitions really well from the previuos level in combining two concepts which i learned from rpevious levels
- worst level?
    - the last level was far too complex
    - if there was a more gradual transition I would have enjoyed it more
- if it used all 3 teammates AIs it would be more interseting having 3 small problems acros sthe 3 AIs and interact.
    - having big functions isn;t fun, having a lot of really small functions would make it really enjoyable.
    - being able to control all 3 characters would be really fun if it was able to have more restrictions on function placmene
    - the main function was making the functions have a valid output, but e.g. if functions give valid outputs and its not productive to the boss fight
        - adds more game complexity without functional rpogramming complexity.
        - open problems rahte rthan closed golden path
        - make the game play more of a part makes it more enjoyable than increasing functional programming
        - multiple agents moving around would be fun, if things like units have to be placed correctly rather than making 
        - multiplve valid outputs for functions, evne if that means the outputs aren't helpful in solving the level.
        - small easy to understand things, trick them into learning

