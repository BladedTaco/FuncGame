#line 1 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27\\Source\\Generated\\out_pre.h"


#pragma once

#line 1 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27/Source/HonoursProj\\MacroUtils.h"


#pragma once
#line 1 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27\\Source\\HonoursProj\\LoopMacros.h"


#pragma once














































































































































































































#line 5 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27/Source/HonoursProj\\MacroUtils.h"
















































































































































































   









#line 6 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27\\Source\\Generated\\out_pre.h"

#line 1 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27/Source/HonoursProj\\Preprocess/Include.h"
#pragma once














#line 17 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27/Source/HonoursProj\\Preprocess/Include.h"






#line 8 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27\\Source\\Generated\\out_pre.h"








include "CoreMinimal.h"
include "Algo/Transform.h"

#line 20 "S:\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj 4.27\\Source\\Generated\\out_pre.h"




template <typename IntType, typename EnumType, EnumType... Vals>
inline constexpr bool IsMember(IntType n) {
	return ((n == static_cast< IntType >(Vals)) || ...);
}






















 




























PP__NEWLINE UENUM(BlueprintType) PP__NEWLINE enum class EType : uint8 { PP__NEWLINE ERROR = 0, PP__NEWLINE NONE, INT, FLOAT, BOOL, CHAR PP__NEWLINE , ANY, EQ, ORDINAL, ENUM, BOUNDED, SHOW, READ, FUNCTOR, APPLICATIVE, MONAD, SEMIGROUP, FOLDABLE, TRAVERSABLE, MONOID, NUM, ALTERNATIVE PP__NEWLINE , EITHER, FUNC, LIST, MAYBE PP__NEWLINE PP__NEWLINE }; PP__NEWLINE PP__NEWLINE UENUM(BlueprintType) PP__NEWLINE enum class ETypeBase : uint8 { PP__NEWLINE ERROR = 0, PP__NEWLINE NONE = (uint8)EType::NONE PP__NEWLINE , INT = (uint8)EType::INT PP__NEWLINE , FLOAT = (uint8)EType::FLOAT PP__NEWLINE , BOOL = (uint8)EType::BOOL PP__NEWLINE , CHAR = (uint8)EType::CHAR PP__NEWLINE PP__NEWLINE }; PP__NEWLINE template <typename IntType> PP__NEWLINE inline constexpr bool IsETypeBase(IntType from) { PP__NEWLINE return IsMember<IntType, ETypeBase, ETypeBase::NONE , ETypeBase::INT , ETypeBase::FLOAT , ETypeBase::BOOL , ETypeBase::CHAR>(from); PP__NEWLINE } PP__NEWLINE UENUM(BlueprintType) PP__NEWLINE enum class ETypeClass : uint8 { PP__NEWLINE ERROR = 0, PP__NEWLINE ANY = (uint8)EType::ANY PP__NEWLINE , EQ = (uint8)EType::EQ PP__NEWLINE , ORDINAL = (uint8)EType::ORDINAL PP__NEWLINE , ENUM = (uint8)EType::ENUM PP__NEWLINE , BOUNDED = (uint8)EType::BOUNDED PP__NEWLINE , SHOW = (uint8)EType::SHOW PP__NEWLINE , READ = (uint8)EType::READ PP__NEWLINE , FUNCTOR = (uint8)EType::FUNCTOR PP__NEWLINE , APPLICATIVE = (uint8)EType::APPLICATIVE PP__NEWLINE , MONAD = (uint8)EType::MONAD PP__NEWLINE , SEMIGROUP = (uint8)EType::SEMIGROUP PP__NEWLINE , FOLDABLE = (uint8)EType::FOLDABLE PP__NEWLINE , TRAVERSABLE = (uint8)EType::TRAVERSABLE PP__NEWLINE , MONOID = (uint8)EType::MONOID PP__NEWLINE , NUM = (uint8)EType::NUM PP__NEWLINE , ALTERNATIVE = (uint8)EType::ALTERNATIVE PP__NEWLINE PP__NEWLINE }; PP__NEWLINE template <typename IntType> PP__NEWLINE inline constexpr bool IsETypeClass(IntType from) { PP__NEWLINE return IsMember<IntType, ETypeClass, ETypeClass::ANY , ETypeClass::EQ , ETypeClass::ORDINAL , ETypeClass::ENUM , ETypeClass::BOUNDED , ETypeClass::SHOW , ETypeClass::READ , ETypeClass::FUNCTOR , ETypeClass::APPLICATIVE , ETypeClass::MONAD , ETypeClass::SEMIGROUP , ETypeClass::FOLDABLE , ETypeClass::TRAVERSABLE , ETypeClass::MONOID , ETypeClass::NUM , ETypeClass::ALTERNATIVE>(from); PP__NEWLINE } PP__NEWLINE UENUM(BlueprintType) PP__NEWLINE enum class ETypeData : uint8 { PP__NEWLINE ERROR = 0, PP__NEWLINE EITHER = (uint8)EType::EITHER PP__NEWLINE , FUNC = (uint8)EType::FUNC PP__NEWLINE , LIST = (uint8)EType::LIST PP__NEWLINE , MAYBE = (uint8)EType::MAYBE PP__NEWLINE PP__NEWLINE }; PP__NEWLINE template <typename IntType> PP__NEWLINE inline constexpr bool IsETypeData(IntType from) { PP__NEWLINE return IsMember<IntType, ETypeData, ETypeData::EITHER , ETypeData::FUNC , ETypeData::LIST , ETypeData::MAYBE>(from); PP__NEWLINE }


































inline bool operator< (const EType lhs, const EType rhs) {
	
	if (rhs == EType::ANY) { return lhs != EType::ANY; }
	
	switch (rhs) { PP__NEWLINE case EType::EQ: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::BOOL: return true; PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::INT: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::ORDINAL: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::BOOL: return true; PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::INT: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::ENUM: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::BOOL: return true; PP__NEWLINE case EType::INT: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::BOUNDED: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::BOOL: return true; PP__NEWLINE case EType::INT: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::SHOW: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::BOOL: return true; PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::INT: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::READ: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::BOOL: return true; PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::INT: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::FUNCTOR: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::FUNC: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::APPLICATIVE: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::FUNC: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::MONAD: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::FUNC: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::SEMIGROUP: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::FUNC: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::FOLDABLE: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::TRAVERSABLE: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::EITHER: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::MONOID: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::FUNC: return true; PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::NUM: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::INT: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE case EType::ALTERNATIVE: PP__NEWLINE switch (lhs) { PP__NEWLINE case EType::LIST: return true; PP__NEWLINE case EType::MAYBE: return true; PP__NEWLINE default: return false; PP__NEWLINE } PP__NEWLINE break; PP__NEWLINE } ;
	
	return false;
}
inline bool operator > (const EType lhs, const EType rhs) { return rhs < lhs; } PP__NEWLINE inline bool operator <= (const EType lhs, const EType rhs) { return (lhs == rhs) || (lhs < rhs); } PP__NEWLINE inline bool operator >= (const EType lhs, const EType rhs) { return (lhs == rhs) || (lhs > rhs); } PP__NEWLINE ;

















































































































































