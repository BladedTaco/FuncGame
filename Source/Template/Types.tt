<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".txt" #>

<#@ include file="$(ProjectDir)\T4.FileManager.VisualStudio19.ttinclude" #>

<#
string ProjectDir = Host.ResolveParameterValue(null, null, "dir");

// get Types XML object
XMLDefinition XML = FromXml<XMLDefinition>(Path.GetFullPath(ProjectDir + "/Source/Template/Types.xml"));

// Start Common File Header
var fileManager = T4FileManager.Create(this).EnableAutoIndent();
fileManager.StartHeader();
#>
// ---------------------------------------------------------------------------------------
// This File ($filename$) is automatically generated by Types.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
<#
fileManager.FinishHeader();
// End Common File Header

// For Each Type
foreach (TypeDefinition type in XML.types) {
    string file = "Type_" + type.name;
    fileManager.StartNewFile(file + ".gen.h", "HonoursProj", Path.Combine(ProjectDir, 'Source', 'HonoursProj'));
#>
#pragma once

#import "AssetLoader.h"

<# if (type.templates != '') { #>template <<#=type.templates#>><# } #>
struct <#=file#> {
private:
public:
    <# foreach (FunctionDefinition func in type.functions) { #>
    <#=func.signature#><#if (function.pure_virtual) { #> = 0<# } #>;
    <# } #>
}
<# } fileManager.Process(); #>







<# foreach (ResourceDefinition resourceDef in resources) { #>
struct FResource_<#=resourceDef.name #> {
	<# foreach (AssetDefinition asset in resourceDef.privateMembers) { #>
	ConstructorHelpers::FObjectFinderOptional<<#=asset.type #>> <#=asset.name#>;
	<# } #>
	FResource_<#=resourceDef.name #>()
	<# isComma = false; foreach (AssetDefinition asset in resourceDef.privateMembers) { #>
	<# if (isComma) { #>,<# } else {  #>:<# isComma = true; } #>	<#=asset.name#>(TEXT("<#=asset.location#>"))
	<# } #>
	{}
};
static FResource_<#=resourceDef.name #> ResourceInst_<#=resourceDef.name #>;

<# } #>


struct FAssets {
	<# foreach (ResourceDefinition resourceDef in resources) { #>
	FResource_<#=resourceDef.name #> <#=resourceDef.name #>;
	<# } #>
	FAssets()
	<# isComma = false; foreach (ResourceDefinition resourceDef in resources) { #>
	<# if (isComma) { #>,<# } else {  #>:<# isComma = true; } #>	<#=resourceDef.name#>(ResourceInst_<#=resourceDef.name #>)
	<# } #>
	{}
};
static FAssets Assets;






<#+
    public class XMLDefinition {
        public List<TypeDefinition> types;
    }

    public class TypeDefinition {
        public string name;
        public string short_name;
        public string icon;
        public string colour;
        public string templates;
        public List<FunctionDefinition> functions;
    }

    public class FunctionDefinition {
        public string signature;
        public bool pure_virtual;
    }

    // https://stackoverflow.com/a/3187539
    public T FromXml<T>(String xml) {
        T returnedXmlClass = default(T);
        try {
            using (TextReader reader = new StringReader(xml)) {
                try {
                    returnedXmlClass = (T)new XmlSerializer(typeof(T)).Deserialize(reader);
                } catch (InvalidOperationException) {
                    // String passed is not XML, simply return defaultXmlClass
                }
            }
        } catch (Exception ex) {}
        return returnedXmlClass ;        
    }
#>

