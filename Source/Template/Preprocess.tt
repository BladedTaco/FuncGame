<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Diagnostics" #>
<#@ output extension=".gen.h" #>

<#@ include file="C:\Users\v2tac\Desktop\UNI\Semester 8\FIT444X - Honours Thesis\Unreal\HonoursProj\packages\T4.FileManager.VisualStudio.3.1.3\content\T4.FileManager.VisualStudio19.ttinclude" #>

<#
    string ProjectDir = Host.ResolveParameterValue(null, null, "dir");
    PP pp = new PP(ProjectDir);

    // Start Common File Header
    var fileManager = new T4FileManager(this);
    fileManager.StartHeader();
#>
// ---------------------------------------------------------------------------------------
// This File ($filename$) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
<#
    fileManager.FinishHeader();
    // End Common File Header

    string intermediate = Path.Combine(ProjectDir, "Source", "Generated", "out_gen.h");
    string preprocessPath = Path.Combine(ProjectDir, "Source", "Preprocess");

    string[] passes = Directory.GetDirectories(preprocessPath, "*", SearchOption.TopDirectoryOnly);
    Array.Sort(passes, (a, b) => Int32.Parse(new DirectoryInfo(a).Name).CompareTo(Int32.Parse(new DirectoryInfo(b).Name)));

    // for each pass in order 0..N
    foreach (string pass in passes) {
        string[] files = Directory.GetFiles(pass, "*.h", SearchOption.AllDirectories);

        // For each file in the pass
        foreach (string filepath in files) {
            // Get New Files output path and name
            string relativePath = Path.GetDirectoryName(filepath.Replace(pass, "").TrimStart(Path.DirectorySeparatorChar));
            string outputPath = Path.Combine(ProjectDir, "Source", "HonoursProj", relativePath);
            string filebase = Path.GetFileNameWithoutExtension(filepath);
            string outName = filebase + "_gen.h";

            // Preprocess the file to output file
            fileManager.StartNewFile(outName, null, outputPath);
            foreach (string line in pp.Preprocess(filepath)) {
#>
<#=line#>
<#
            }
        }
    }

    // Finish any preprocessor directives leftovers
    pp.Finish(fileManager);

    // Write all files
    fileManager.Process();
#>


<#+

public class Directive {
    public static readonly Regex Args = new Regex(@"[, ]+");
    public static readonly Regex Kwarg = new Regex(@"(?<key>[^=]+)=(?<val>[^=]+)");

    public static (List<string>, Dictionary<string, string>) ParseArgs(string arguments) {
        // Initialize Return containers
        List<string> args = new List<string>();
        Dictionary<string, string> kwargs = new Dictionary<string, string>();

        // For each argument
        foreach (string arg in Directive.Args.Split(arguments)) {
            // Try to match Kwargs
            Match match = Directive.Kwarg.Match(arg);
            if (match.Success) {
                // Add Kwarg to dictionary
                kwargs.Add(match.Groups["key"].Value, match.Groups["val"].Value);
            } else {
                // Add position arg to list
                args.Add(arg);
            }
        }

        return (args, kwargs);
    }

    // Replace Directive Text with Other Text
    public static string ReplaceText(string directiveResult, string originalLine) {
        // Handle non-replacing directives
        if (directiveResult == null) {
            return originalLine;
        }
        // Replace Directive
        Regex directive = new Regex(@"PP__(PRE_)?DIRECTIVE\([^)]+\)");
        return directive.Replace(originalLine, directiveResult);;
    }
}


// Preprocessor Directive
public class PP {

    protected readonly string ProjectDir;
    protected readonly string Generated;
    protected readonly string Preprocessed;

    
    // New Include
    protected static Regex srcFile = new Regex("^#line 1 (?<file>.+)$");
    // Removed Import
    protected static Regex skippedImport = new Regex("^include (<.+>|\".+\")$");

    public PP(string ProjectDir) {
        // get project directory
        this.ProjectDir = ProjectDir;
        // Get Preprocessed File
        this.Preprocessed = Path.Combine(this.ProjectDir, "Source", "Generated", "out_pre.h");
        // Get intermediate file
        this.Generated = Path.Combine(this.ProjectDir, "Source", "Generated", "out_gen.h");
    }

    protected string RunPreDirectives(string filepath) {
        // Write to output file
        string outputFile = Path.Combine(this.ProjectDir, "Source", "Generated", "out_pre.h");
        using (StreamWriter writer = new StreamWriter(outputFile)) {
            // For each line in input file
            foreach (string line in File.ReadLines(filepath)) {
                // Copy across any lines that aren't directives
                writer.WriteLine(this.RunDirective(line, true) ?? line);
            }
        }
        return outputFile;
    }

    protected IEnumerable<string> RunPP(string filepath) {
        // Run any predirectives
        filepath = this.RunPreDirectives(filepath);

        // Start the child process.
        System.Diagnostics.Process p = new System.Diagnostics.Process();
        // Redirect the output stream of the child process.
        p.StartInfo.CreateNoWindow = true;
        p.StartInfo.UseShellExecute = false;
        //p.StartInfo.RedirectStandardOutput = true;
        p.StartInfo.FileName = "C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Auxiliary/Build/vcvarsall.bat";
        p.StartInfo.Arguments = $"x86 & cl /std:c++17 /Zc:preprocessor /TP /MT /P /permissive /D\"PP__PREPROCESSING\" /Fi\"{this.Generated}\" /I\"{this.ProjectDir}/Source/HonoursProj\" \"{filepath}\"";

        p.Start();
        // Do not wait for the child process to exit before
        // reading to the end of its redirected stream.
        // p.WaitForExit();
        // Read the output stream first and then wait.
        //string output = p.StandardOutput.ReadToEnd();
        p.WaitForExit();

        return File.ReadLines(this.Generated);
    }

    // Preprocess a File
    public IEnumerable<string> Preprocess(string filepath) {
        string filename = Path.GetFileName(filepath);

        // Define line regex
        Regex thisFile = new Regex($"^#line [0-9]+ \"{this.Preprocessed.Replace(@"\", @"\\\\")}\"$");
        bool validOutput = false;
    
        // For each line in preprocessed file
        foreach (string line in this.RunPP(filepath)) {
            // Output lines when the last line directive was for the file
            if (thisFile.IsMatch(line)) {
                validOutput = true;
            // Include new file when moving from outermost file to line 1 of new file
            } else if (PP.srcFile.IsMatch(line) && validOutput) {
                validOutput = false;
                Match match = PP.srcFile.Match(line);    
                yield return $"#include {match.Groups["file"].Value}"; 
            // Else Write line from original file
            } else if (validOutput) {
                // If the line is not empty
                if (!string.IsNullOrWhiteSpace(line)) {
                    // For each subline for line split by the newline directive
                    foreach (string subline in line.Split(new [] {"PP__NEWLINE"}, StringSplitOptions.None)) {
                        // Add in #'s before skipped imports
                        string prepend = (PP.skippedImport.IsMatch(line) ? "#" : "");
                        // Check for preprocessing directives, but otherwise print line
                        yield return this.RunDirective(prepend + subline, false);
                    }
                }
            }
        }
        yield break;
    }

    public List<string> TypeClasses = new List<string>();
    public List<string> DataClasses = new List<string>();
    public Dictionary<string, List<string>> Implementations = new Dictionary<string, List<string>>();

    public string RunDirective(string line, bool pre) {
        // Check for preprocessing directives
        Match match;
        if (pre) {
            match = this.PreDirectiveMacro.Match(line);
        } else {
            match = this.DirectiveMacro.Match(line);
        }
        if (match.Success) {
            // Call directive handling function
            string directive = match.Groups["directive"].Value;
            return Directive.ReplaceText(this.DirectiveDict[directive](this, match.Groups["data"].Value), line);
        }
        return line;
    }

    public void Finish(T4FileManager fileManager) {
        // Nothing yet
    }

    // Directive Names and Logic
    public readonly Regex DirectiveMacro =        new Regex(@"PP__DIRECTIVE\((?<directive>[^, ]+)[, ]+(?<data>[^)]+)?\)");
    public readonly Regex PreDirectiveMacro = new Regex(@"PP__PRE_DIRECTIVE\((?<directive>[^, ]+)[, ]+(?<data>[^)]+)?\)");
    public readonly Dictionary<string, Func<PP, string, string>> DirectiveDict = new Dictionary<string, Func<PP, string, string>>(){
        {"Typeclass", (PP pp, string data) => {
            string[] items = data.Split(new [] {", "}, StringSplitOptions.None);
            string cls = items[0];
            string inst = items[1];
            // Add Typeclass if not yet added
            if (!pp.TypeClasses.Contains(cls)) {
                pp.TypeClasses.Add(cls);
                pp.Implementations.Add(cls, new List<string>());
            }
            // Add Dataclass if not yet added
            if (!pp.DataClasses.Contains(inst)) {
                pp.DataClasses.Add(inst);
            }
            // Add Implementation
            pp.Implementations[cls].Add(inst);
            // Paste out comment in place of directive
            return $"/*Added Typeclass {cls} Instance {inst}*/";
        }},
        {"Print", (PP pp, string data) => {
            // Parse Arguments
            (List<string> args, Dictionary<string, string> kwargs) = Directive.ParseArgs(data);
            string itemType = args[0];
            string memberName = args[1];

            var member = typeof(PP).GetField(memberName).GetValue(pp);

            // Get Base Output
            string output = "";
            switch (itemType) {
                case "List":
                    // Print out List
                    output = String.Join(", ", (List<string>)member);
                    break;
                case "Dict":
                    // Print out Dictionary ...
                    Dictionary<string, List<string>> dict = (Dictionary<string, List<string>>)member;
                    if (kwargs.ContainsKey("Key")) {
                        // Entry as list
                        output = String.Join(", ", dict[kwargs["Key"]]);
                    } else {
                        // Bracketed Key,Value pairs list
                        List<string> items = new List<string>();
                        foreach (var keyVal in dict) {
                            items.Add($"({keyVal.Key}, {String.Join(", ", keyVal.Value)})");
                        }
                        output = String.Join(", ", items);
                    }
                    break;
            }

            // Apply Kwarg transformations
            if (kwargs.ContainsKey("Case")) {
                switch (kwargs["Case"]) {
                    case "Capitalize":
                        output = output.ToUpper();
                        break;
                }
            }

            // return output to be pasted into file
            return output;
        }}
    };
};

#>