<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ output extension=".gen.h" #>

<#@ include file="C:\Users\v2tac\Desktop\UNI\Semester 8\FIT444X - Honours Thesis\Unreal\HonoursProj\packages\T4.FileManager.VisualStudio.3.1.3\content\T4.FileManager.VisualStudio19.ttinclude" #>

<#
    string ProjectDir = Host.ResolveParameterValue(null, null, "dir");
    PP pp = new PP(ProjectDir);

    // Start Common File Header
    var fileManager = new T4FileManager(this);
    fileManager.StartHeader();
#>
// ---------------------------------------------------------------------------------------
// This File ($filename$) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
<#
    fileManager.FinishHeader();
    // End Common File Header

    string intermediate = Path.Combine(ProjectDir, "Source", "Generated", "out_gen.h");
    string preprocessPath = Path.Combine(ProjectDir, "Source", "Preprocess");

    string[] passes = Directory.GetDirectories(preprocessPath, "*", SearchOption.TopDirectoryOnly);
    Array.Sort(passes, (a, b) => Int32.Parse(new DirectoryInfo(a).Name).CompareTo(Int32.Parse(new DirectoryInfo(b).Name)));

    // for each pass in order 0..N
    foreach (string pass in passes) {
        string passPath = Path.Combine(preprocessPath, pass);
        string[] files = Directory.GetFiles(passPath, "*.h", SearchOption.AllDirectories);

        // For each file in the pass
        foreach (string filepath in files) {
            // Get New Files output path and name
            string relativePath = filepath.Replace(passPath, "");
            string outputPath = Path.Combine(ProjectDir, "Source", "HonoursProj", relativePath);
            string filebase = Path.GetFileNameWithoutExtension(filepath);
            string outName = filebase + "_gen.h";

            // Preprocess the file to output file
            fileManager.StartNewFile(outName, null, outputPath);
            foreach (string line in pp.Preprocess(filepath)) {
#>
<#=line#>
<#
            }
        }
    }

    // Finish any preprocessor directives leftovers
    pp.Finish(fileManager);

    // Write all files
    fileManager.Process();
#>


<#+
// Preprocessor Directive
public class PP {

    protected string ProjectDir;

    
    // New Include
    protected static Regex srcFile = new Regex("^#line 1 (?<file>.+)$");
    // Removed Import
    protected static Regex skippedImport = new Regex("^include (<.+>|\".+\")$");

    public PP(string ProjectDir) {
        this.ProjectDir = ProjectDir;
    }

    protected string RunPreDirectives(string filepath) {
        // Write to output file
        string outputFile = Path.Combine(this.ProjectDir, "Source", "Generated", "out_pre.h");
        using (StreamWriter writer = new StreamWriter(outputFile)) {
            // For each line in input file
            foreach (string line in File.ReadLines(filepath)) {
                // Copy across any lines that aren't directives
                writer.WriteLine(this.RunDirective(line, true) ?? line);
            }
        }
        return outputFile;
    }

    protected IEnumerable<string> RunPP(string filepath) {
        // Run any predirectives
        filepath = this.RunPreDirectives(filepath);

        // Get intermediate file
        string intermediate = Path.Combine(this.ProjectDir, "Source", "Generated", "out_gen.h");

        // Start the child process.
        System.Diagnostics.Process p = new System.Diagnostics.Process();
        // Redirect the output stream of the child process.
        p.StartInfo.CreateNoWindow = true;
        p.StartInfo.UseShellExecute = false;
        //p.StartInfo.RedirectStandardOutput = true;
        p.StartInfo.FileName = "C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Auxiliary/Build/vcvarsall.bat";
        p.StartInfo.Arguments = $"x86 & cl /std:c++17 /Zc:preprocessor /TP /MT /P /permissive /D\"PP__PREPROCESSING\" /Fi\"{intermediate}\" /I\"{this.ProjectDir}/Source/HonoursProj\" \"{filepath}\"";

        p.Start();
        // Do not wait for the child process to exit before
        // reading to the end of its redirected stream.
        // p.WaitForExit();
        // Read the output stream first and then wait.
        //string output = p.StandardOutput.ReadToEnd();
        p.WaitForExit();

        return File.ReadLines(intermediate);
    }

    // Preprocess a File
    public IEnumerable<string> Preprocess(string filepath) {
        string filename = Path.GetFileName(filepath);

        // Define line regex
        Regex thisFile = new Regex($"^#line.+{filename}\"$");
        bool validOutput = false;
    
        // For each line in preprocessed file
        foreach (string line in this.RunPP(filepath)) {
            // Output lines when the last line directive was for the file
            if (thisFile.IsMatch(line)) {
                validOutput = true;
            // Include new file when moving from outermost file to line 1 of new file
            } else if (PP.srcFile.IsMatch(line) && validOutput) {
                validOutput = false;
                Match match = PP.srcFile.Match(line);    
                yield return $"#include {match.Groups["file"].Value}"; 
            // Else Write line from original file
            } else if (validOutput) {
                // If the line is not empty
                if (!string.IsNullOrWhiteSpace(line)) {
                    // For each subline for line split by the newline directive
                    foreach (string subline in line.Split(new [] {"PP__NEWLINE"}, StringSplitOptions.None)) {
                        // Add in #'s before skipped imports
                        // Check for preprocessing directives, but otherwise print line
                        yield return $"{(PP.skippedImport.IsMatch(line) ? "#" : "")}{this.RunDirective(subline, false) ?? subline}";
                    }
                }
            }
        }
    }

    public List<string> Typeclasses = new List<string>();
    public List<string> DataClasses = new List<string>();

    public string RunDirective(string line, bool pre) {
        // Check for preprocessing directives
        Match match;
        if (pre) {
            match = this.PreDirectiveMacro.Match(line);
        } else {
            match = this.DirectiveMacro.Match(line);
        }
        if (match.Success) {
            // Call directive handling function
            string directive = match.Groups["directive"].Value;
            return this.DirectiveDict[directive](this, match.Groups["data"].Value);
        }
        return null;
    }

    public void Finish(T4FileManager fileManager) {
        // Nothing yet
    }

    // Directive Names and Logic
    public readonly Regex DirectiveMacro = new Regex(@"PP__DIRECTIVE\((?<directive>.+)(, )?(?<data>.+)?\)");
    public readonly Regex PreDirectiveMacro = new Regex(@"PP__PRE_DIRECTIVE\((?<directive>.+)(, )?(?<data>.+)?\)");
    public readonly Dictionary<string, Func<PP, string, string>> DirectiveDict = new Dictionary<string, Func<PP, string, string>>(){
        {"Typeclass", (PP pp, string data) => {
            string[] items = data.Split(new [] {", "}, StringSplitOptions.None);
            string cls = items[0];
            string inst = items[1];
            if (!pp.Typeclasses.Contains(cls)) {
                pp.Typeclasses.Add(cls);
            }
            if (!pp.DataClasses.Contains(inst)) {
                pp.DataClasses.Add(inst);
            }
            return "";
        }},
        {"Print", (PP pp, string data) => {
            // Get all elements of specified list
            List<string> output = new List<string>();
            foreach (string element in pp.Typeclasses) {
                output.Add(element.ToUpper());
            }
            // return list capitalized
            return String.Join(", ", output);
        }}
    };
};

#>