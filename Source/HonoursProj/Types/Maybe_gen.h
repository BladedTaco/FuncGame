// ---------------------------------------------------------------------------------------
// This File (Maybe_gen.h) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
#pragma once
#include "C:\\Users\\v2tac\\Desktop\\UNI\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj/Source/HonoursProj\\Types/Functor.h"
#include "C:\\Users\\v2tac\\Desktop\\UNI\\Semester 8\\FIT444X - Honours Thesis\\Unreal\\HonoursProj/Source/HonoursProj\\Types/Show.h"
#include "Misc/Optional.h"
class IMaybe : public virtual ITypeclass {
private:
	virtual const Typeclass* _GetTypeclass() const override {
		return &IMaybe::Instances;
	}
public:
	class Functor : public virtual IFunctor {
	private:
		virtual VStar _fmap(const VStar& f, const VStar& f_a) const override;
	public:
		Functor() = default;
	}; 
	inline static const Functor FunctorInst = {};
	class Show : public virtual IShow {
	private:
		virtual FString _show(const VStar& a) const override;
	public:
		Show() = default;
	};
	inline static const Show ShowInst = {};
public:
	static const inline Typeclass Instances = []{ Typeclass ${}; $.Functor = &IMaybe::FunctorInst; $.Show = &IMaybe::ShowInst;; return $; }()
;
};
template <typename A>
class Maybe : public virtual IMaybe {
private:
	bool _isNothing;
	TOptional<A> _value;
	Maybe() {
		_isNothing = true;
	}
	Maybe(A a) {
		_isNothing = false;
		_value = a;
	}
	friend IMaybe::Functor;
	friend IMaybe::Show;
	friend class ::Functor<Maybe<A>>;
	friend MaybeV;
public:
	virtual ~Maybe() = default;
	static Maybe<A> Just(A a) {
		return Maybe<A>(a);
	}
	static Maybe<A> Nothing() {
		return Maybe<A>();
	}
public:
	A fromMaybe(A fallback) {
		if (_isNothing) {
			return fallback;
		} else {
			return _value.GetValue();
		}
	}
	Maybe(const MaybeV* other);
};
template <>
class Maybe<VStar> : public virtual IMaybe {
private:
	friend VStar;
	friend Maybe;
	friend IMaybe::Functor;
	friend IMaybe::Show;
	template <typename A>
	friend Maybe<A>::Maybe(const MaybeV* other);
	bool _isNothing;
	VStar _value;
	Maybe() {
		_isNothing = true;
	}
	Maybe(VStar from) {
		_isNothing = false;
		_value = from;
	}
	friend class ::Functor<MaybeV>;
public:
	virtual ~Maybe() = default;
	template <typename A>
	static MaybeV Just(A a) {
		return MaybeV::Maybe(VStar(a));
	}
	template <>
	static MaybeV Just(VStar a) {
		return MaybeV::Maybe(a);
	}
	static MaybeV Nothing() {
		return MaybeV::Maybe();
	}
public:
	template <typename A>
	A fromMaybe(A fallback) {
		if (_isNothing) {
			return fallback;
		} else {
			return _value.ResolveToUnsafe<A>();
		}
	}
	template <>
	VStar fromMaybe(VStar fallback) {
		if (_isNothing) {
			return fallback;
		} else {
			return _value;
		}
	}
};
template <typename A>
Maybe<A>::Maybe(const MaybeV* other) {
	_isNothing = other->_isNothing;
	if (!_isNothing) {
		_value = other->_value.ResolveToUnsafe<A>();
	}
}
inline VStar IMaybe::Functor::_fmap(const VStar& f, const VStar& f_a) const {
	ArrV g = f.ResolveToUnsafe<ArrV>();
	MaybeV m_a = f_a.ResolveToUnsafe<MaybeV>();
	if (m_a._isNothing) {
		return VStar(MaybeV::Nothing());
	} else {
		VStar result = g(m_a._value);
		return VStar(MaybeV::Just(result));
	}
}
inline FString IMaybe::Show::_show(const VStar& a) const {
	MaybeV m_a = a.ResolveToUnsafe<MaybeV>();
	if (m_a._isNothing) {
		return FString(TEXT("Nothing"));
	} else {
		FString inner = m_a._value.getTypeclass()->Show->show()(m_a._value);
		return FString(TEXT("Just ")) + inner;
	}
}
template <typename A>
auto fromMaybe = curry([](A a, Maybe<A> m_a) -> A {
	return m_a.fromMaybe(a);
});

 /*Added Typeclass Functor Instance Maybe*/ 
 template <class A> 
 class Functor<Maybe <A> > : public BaseFunctor<Maybe,A> { 
 private: 
 template <class B> 
 inline static auto _fmap = [](Arr<A, B> func, Maybe<A> f_a) -> Maybe<B> { 
 if (f_a._isNothing) { 
 return Maybe<B>::Nothing(); 
 } else { 
 return Maybe<B>::Just(func(f_a._value.GetValue())); 
 } 
 }; 
 public: 
 template <class B> 
 inline static auto fmap = curry(_fmap<B>); 
 };
;

 /*Added Typeclass Show Instance Maybe*/ 
 ;
