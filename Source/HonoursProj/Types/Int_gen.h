// ---------------------------------------------------------------------------------------
// This File (Int_gen.h) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
#pragma once
#include "Types\Ord.h"
#include "Types\Show.h"
#include "Types/VStar.h"
template <typename A>
class INumber : public virtual ITypeclass {
private:
	virtual const Typeclass* _GetTypeclass() const override {
		return &INumber<A>::Instances;
	}
public:
	class Ordinal : public virtual IOrdinal {
	private:
		virtual ORD _ord(const VStar& me, const VStar& other) const override;
	public:
		Ordinal() = default;
	};
	inline static const Ordinal OrdinalInst = {};
	class Show : public virtual IShow {
	private:
		virtual FString _show(const VStar& me) const override;
	public:
		Show() = default;
	};
	inline static const Show ShowInst = {};
public:
	static const inline Typeclass Instances = []{ Typeclass ${}; $.Ordinal = &INumber<A>::OrdinalInst; $.Show = &INumber<A>::ShowInst;; return $; }()
;
};
template <typename A>
class Number : public virtual INumber<A> {
private:
	A _value;
	friend NumberV;
	friend class ::Ordinal<Number<A>>;
public:
	virtual ~Number() = default;
	Number(A value) : _value(value) {}
	virtual A get() const { return _value; }
	Number(const NumberV* other);
};
template <>
class Number<VStar> : public virtual ITypeclass {
private:
	friend VStar;
	friend Number;
	template <typename A>
	friend Number<A>::Number(const NumberV* other);
	VStar _value;
	friend class ::Ordinal<NumberV>;
	const Typeclass* Instances;
	virtual const Typeclass* _GetTypeclass() const override {
		return Instances;
	}
public:
	template <typename T>
	void SetTypeclass() {
		Instances = &INumber<T>::Instances;
	}
	virtual ~Number() = default;
	template <typename A>
	Number(A value)
		: _value(value) {
		SetTypeclass<A>();
	};
	template <typename A>
	const A* get() const { return _value.GetUnsafePtr<A>(); }
	template <typename A>
	Number(const Number<A>& other) 
		: _value(other.get()) {
		SetTypeclass<A>();
	}
	template <>
	Number(const NumberV& other)
		: _value(other._value) 
		, Instances(other.GetTypeclass()) {};
	Number(const NumberV& other) {
		_value = other._value;
		Instances = other.GetTypeclass();
	};
	Number(NumberV&& other) {
		_value = VStar(other);
		Instances = other.GetTypeclass();
	}
};
template <typename A>
Number<A>::Number(const NumberV* other) {
	_value = other->_value.ResolveToUnsafe<A>();
}
template <typename A>
inline ORD INumber<A>::Ordinal::_ord(const VStar& me, const VStar& other) const {
	A a = me.ResolveToUnsafe<Number<A>>().get();
	A b = other.ResolveToUnsafe<Number<A>>().get();
	return a == b ? ORD::EQ : a < b ? ORD::LT : ORD::GT;
}
template <typename A>
inline FString INumber<A>::Show::_show(const VStar& me) const {
	A a = me.ResolveToUnsafe<Number<A>>().get();
	return FString::Format(TEXT("{0}"), { a });
}

 /*Added Typeclass Ordinal Instance Number*/ 
 template <class A> 
 class Ordinal<Number <A> > : public BaseOrdinal<Number <A> > { 
 private: 
 template <class = void*> 
 inline static auto _ord = [](Number<A> a, Number<A> b) -> ORD { 
 return a._value == b._value ? ORD::EQ : a._value < b._value ? ORD::LT : ORD::GT; 
 }; 
 public: 
 template <class = void*> 
 inline static auto ord = curry(_ord<>); 
 };
;

 /*Added Typeclass Show Instance Number*/ 
 ;
