// ---------------------------------------------------------------------------------------
// This File (Types_gen.h) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
#pragma once
#include "MacroUtils.h"
#include "Preprocess\Include.h"
#include "CoreMinimal.h"
#include "Algo/Transform.h"
template <typename IntType, typename EnumType, EnumType... Vals>
inline constexpr bool IsMember(IntType n) {
	return ((n == static_cast< IntType >(Vals)) || ...);
}

 UENUM(BlueprintType) 
 enum class EType : uint8 { 
 ERROR = 0, 
 NONE, INT, FLOAT, BOOL, CHAR 
 , ANY, EQ, ORDINAL, ENUM, BOUNDED, SHOW, READ, FUNCTOR, APPLICATIVE, MONAD, SEMIGROUP, FOLDABLE, TRAVERSABLE, MONOID, NUM, ALTERNATIVE 
 , EITHER, FUNC, LIST, MAYBE 
 
 }; 
 
 UENUM(BlueprintType) 
 enum class ETypeBase : uint8 { 
 ERROR = 0, 
 NONE = (uint8)EType::NONE 
 , INT = (uint8)EType::INT 
 , FLOAT = (uint8)EType::FLOAT 
 , BOOL = (uint8)EType::BOOL 
 , CHAR = (uint8)EType::CHAR 
 
 }; 
 template <typename IntType> 
 inline constexpr bool IsETypeBase(IntType from) { 
 return IsMember<IntType, ETypeBase, ETypeBase::NONE , ETypeBase::INT , ETypeBase::FLOAT , ETypeBase::BOOL , ETypeBase::CHAR>(from); 
 } 
 UENUM(BlueprintType) 
 enum class ETypeClass : uint8 { 
 ERROR = 0, 
 ANY = (uint8)EType::ANY 
 , EQ = (uint8)EType::EQ 
 , ORDINAL = (uint8)EType::ORDINAL 
 , ENUM = (uint8)EType::ENUM 
 , BOUNDED = (uint8)EType::BOUNDED 
 , SHOW = (uint8)EType::SHOW 
 , READ = (uint8)EType::READ 
 , FUNCTOR = (uint8)EType::FUNCTOR 
 , APPLICATIVE = (uint8)EType::APPLICATIVE 
 , MONAD = (uint8)EType::MONAD 
 , SEMIGROUP = (uint8)EType::SEMIGROUP 
 , FOLDABLE = (uint8)EType::FOLDABLE 
 , TRAVERSABLE = (uint8)EType::TRAVERSABLE 
 , MONOID = (uint8)EType::MONOID 
 , NUM = (uint8)EType::NUM 
 , ALTERNATIVE = (uint8)EType::ALTERNATIVE 
 
 }; 
 template <typename IntType> 
 inline constexpr bool IsETypeClass(IntType from) { 
 return IsMember<IntType, ETypeClass, ETypeClass::ANY , ETypeClass::EQ , ETypeClass::ORDINAL , ETypeClass::ENUM , ETypeClass::BOUNDED , ETypeClass::SHOW , ETypeClass::READ , ETypeClass::FUNCTOR , ETypeClass::APPLICATIVE , ETypeClass::MONAD , ETypeClass::SEMIGROUP , ETypeClass::FOLDABLE , ETypeClass::TRAVERSABLE , ETypeClass::MONOID , ETypeClass::NUM , ETypeClass::ALTERNATIVE>(from); 
 } 
 UENUM(BlueprintType) 
 enum class ETypeData : uint8 { 
 ERROR = 0, 
 EITHER = (uint8)EType::EITHER 
 , FUNC = (uint8)EType::FUNC 
 , LIST = (uint8)EType::LIST 
 , MAYBE = (uint8)EType::MAYBE 
 
 }; 
 template <typename IntType> 
 inline constexpr bool IsETypeData(IntType from) { 
 return IsMember<IntType, ETypeData, ETypeData::EITHER , ETypeData::FUNC , ETypeData::LIST , ETypeData::MAYBE>(from); 
 }
inline bool operator< (const EType lhs, const EType rhs) {
	if (rhs == EType::ANY) { return lhs != EType::ANY; }
	switch (rhs) { 
 case EType::EQ: 
 switch (lhs) { 
 case EType::BOOL: return true; 
 case EType::EITHER: return true; 
 case EType::INT: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::ORDINAL: 
 switch (lhs) { 
 case EType::BOOL: return true; 
 case EType::EITHER: return true; 
 case EType::INT: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::ENUM: 
 switch (lhs) { 
 case EType::BOOL: return true; 
 case EType::INT: return true; 
 default: return false; 
 } 
 break; 
 case EType::BOUNDED: 
 switch (lhs) { 
 case EType::BOOL: return true; 
 case EType::INT: return true; 
 default: return false; 
 } 
 break; 
 case EType::SHOW: 
 switch (lhs) { 
 case EType::BOOL: return true; 
 case EType::EITHER: return true; 
 case EType::INT: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::READ: 
 switch (lhs) { 
 case EType::BOOL: return true; 
 case EType::EITHER: return true; 
 case EType::INT: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::FUNCTOR: 
 switch (lhs) { 
 case EType::EITHER: return true; 
 case EType::FUNC: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::APPLICATIVE: 
 switch (lhs) { 
 case EType::EITHER: return true; 
 case EType::FUNC: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::MONAD: 
 switch (lhs) { 
 case EType::EITHER: return true; 
 case EType::FUNC: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::SEMIGROUP: 
 switch (lhs) { 
 case EType::EITHER: return true; 
 case EType::FUNC: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::FOLDABLE: 
 switch (lhs) { 
 case EType::EITHER: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::TRAVERSABLE: 
 switch (lhs) { 
 case EType::EITHER: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::MONOID: 
 switch (lhs) { 
 case EType::FUNC: return true; 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 case EType::NUM: 
 switch (lhs) { 
 case EType::INT: return true; 
 default: return false; 
 } 
 break; 
 case EType::ALTERNATIVE: 
 switch (lhs) { 
 case EType::LIST: return true; 
 case EType::MAYBE: return true; 
 default: return false; 
 } 
 break; 
 } ;
	return false;
}
inline bool operator > (const EType lhs, const EType rhs) { return rhs < lhs; } 
 inline bool operator <= (const EType lhs, const EType rhs) { return (lhs == rhs) || (lhs < rhs); } 
 inline bool operator >= (const EType lhs, const EType rhs) { return (lhs == rhs) || (lhs > rhs); } 
 ;
