// ---------------------------------------------------------------------------------------
// This File (Applicative_gen.h) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
#pragma once
#include "MacroUtils.h"
#include "Functional\Prelude.h"
#include "Functional\Typeclass.h"
#include "Types\Unpack.h"
#include "Types/Typeclass/Functor_gen.h"
;
class IApplicative : public virtual IFunctor {
	public: const Arr<const VStar&, VStar > pure() const { return curry([this]( const VStar& value ) -> VStar { return this->_pure ( value ); }); }; private: virtual VStar _pure ( const VStar& value ) const = 0;
	public: const Arr<const VStar&, Arr<const VStar&, VStar > > apply() const { return curry([this]( const VStar& boxedFunc , const VStar& app ) -> VStar { return this->_apply ( boxedFunc, app ); }); }; private: virtual VStar _apply ( const VStar& boxedFunc , const VStar& app ) const = 0; 
	public: const Arr<const VStar&, Arr<const VStar&, Arr<const VStar&, VStar > > > liftA2() const { return curry([this]( const VStar& ternary , const VStar& boxA , const VStar& boxB ) -> VStar { return this->_liftA2 ( ternary, boxA, boxB ); }); }; private: virtual VStar _liftA2 ( const VStar& ternary , const VStar& boxA , const VStar& boxB ) const {
		VStar f_b = fmap()(ternary)(boxA);
		return apply()(f_b)(boxB);
	};
	public: const Arr<const VStar&, Arr<const VStar&, VStar > > leftApply() const { return curry([this]( const VStar& discard , const VStar& keep ) -> VStar { return this->_leftApply ( discard, keep ); }); }; private: virtual VStar _leftApply ( const VStar& discard , const VStar& keep ) const {
		return liftA2()(PreludeV::constant)(discard)(keep);
	};
	public: const Arr<const VStar&, Arr<const VStar&, VStar > > rightApply() const { return curry([this]( const VStar& keep , const VStar& discard ) -> VStar { return this->_rightApply ( keep, discard ); }); }; private: virtual VStar _rightApply ( const VStar& keep , const VStar& discard ) const {
		VStar f_a = map_replace_by()(PreludeV::id)(discard);
		return apply()(f_a)(keep);
	}
}
