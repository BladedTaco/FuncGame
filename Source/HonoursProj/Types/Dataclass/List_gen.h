// ---------------------------------------------------------------------------------------
// This File (List_gen.h) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
#pragma once
#include "Types\FDecl.h"
#include "Misc/Optional.h"
#include "Types\Typeclass\Functor.h"
#include "Types\Typeclass\Applicative.h"
#include "Types\Typeclass\Monad.h"
#include "Types\Typeclass\Semigroup.h"
#include "Types\Typeclass\Monoid.h"
#include "Types\Typeclass\Foldable.h"
#include "Types\Typeclass\Traversable.h"
#include "Types\Typeclass\Alternative.h"
#include "Types\Typeclass\Eq.h"
#include "Types\Typeclass\Ordinal.h"
#include "Types\Typeclass\Show.h"
#include "Types\Typeclass\Read.h"

 /*Added Typeclass Functor Instance List*/ 
 ;

 /*Added Typeclass Applicative Instance List*/ 
 ;

 /*Added Typeclass Monad Instance List*/ 
 ;

 /*Added Typeclass Semigroup Instance List*/ 
 ;

 /*Added Typeclass Monoid Instance List*/ 
 ;

 /*Added Typeclass Foldable Instance List*/ 
 ;

 /*Added Typeclass Traversable Instance List*/ 
 ;

 /*Added Typeclass Alternative Instance List*/ 
 ;

 /*Added Typeclass Eq Instance List*/ 
 ;

 /*Added Typeclass Ordinal Instance List*/ 
 ;

 /*Added Typeclass Show Instance List*/ 
 ;

 /*Added Typeclass Read Instance List*/ 
 ;
class IList : public virtual ITypeclass {
private:
	virtual TSharedPtr<const Typeclass> _GetTypeclass() const override {
		return NoopPtr(&Instances);
	}
public:
	
 class Functor : public virtual IFunctor { 
 private: 
 virtual VStar _fmap(const VStar& f, const VStar& f_a) const override; 
 public: 
 Functor() = default; 
 }; 
 inline static const Functor FunctorInst = {}; ;
    
 class Applicative : public virtual IApplicative, public virtual Functor { 
 private: 
 virtual VStar _pure(const VStar& value) const override; 
 virtual VStar _apply(const VStar& boxedFunc, const VStar& app) const override; 
 public: 
 Applicative() = default; 
 }; 
 inline static const Applicative ApplicativeInst = {}; ;
    
 class Monad : public virtual IMonad, public virtual Applicative { 
 private: 
 virtual VStar _bind(const VStar& m_a, const VStar& a_to_mb) const override; 
 public: 
 Monad() = default; 
 }; 
 inline static const Monad MonadInst = {}; ;
    
 class Semigroup : public virtual ISemigroup { 
 private: 
 virtual VStar _mappend( const VStar& left, const VStar& right) const override; 
 public: 
 Semigroup() = default; 
 }; 
 inline static const Semigroup SemigroupInst = {}; ;
    
 class Monoid : public virtual IMonoid, public virtual Semigroup { 
 private: 
 virtual VStar _mempty() const override; 
 public: 
 Monoid() = default; 
 }; 
 inline static const Monoid MonoidInst = {}; ;
    
 class Foldable : public virtual IFoldable { 
 private: 
 virtual VStar _foldr(const VStar& f, const VStar& initial, const VStar& foldable) const override; 
 public: 
 Foldable() = default; 
 }; 
 inline static const Foldable FoldableInst = {}; ;
    
 class Traversable : public virtual ITraversable, public virtual Foldable, public virtual Functor { 
 private: 
 virtual VStar _traverse(const VStar& applic, const VStar& f, const VStar& foldable) const override; 
 public: 
 Traversable() = default; 
 }; 
 inline static const Traversable TraversableInst = {}; ;
    
 class Ordinal : public virtual IOrdinal { 
 private: 
 virtual ORD _ord( const VStar& a, const VStar& b) const override; 
 public: 
 Ordinal() = default; 
 }; 
 inline static const Ordinal OrdinalInst = {}; ;
    
 class Show : public virtual IShow { 
 private: 
 virtual FString _show( const VStar& me) const override; 
 public: 
 Show() = default; 
 }; 
 inline static const Show ShowInst = {}; ;
public:
	static const inline Typeclass Instances = []{ Typeclass ${}; $.Functor = &IList::FunctorInst; $.Applicative = &IList::ApplicativeInst; $.Monad = &IList::MonadInst; $.Semigroup = &IList::SemigroupInst; $.Monoid = &IList::MonoidInst; $.Foldable = &IList::FoldableInst; $.Traversable = &IList::TraversableInst; $.Eq = &IList::OrdinalInst; $.Ordinal = &IList::OrdinalInst; $.Show = &IList::ShowInst;; return $; }()
;
};
template <typename A>
class List : public virtual IList {
private:
    VStar _head;
    VStar _rest;
    VStar _next;
	friend IList::Ordinal;
	friend IList::Show;
	friend IList::Functor;
	friend IList::Applicative;
	friend IList::Monad;
	friend IList::Monoid;
	friend IList::Semigroup;
	friend IList::Foldable;
	friend IList::Traversable;
	friend ListV;
	virtual TSharedPtr<const Typeclass> _GetTypeclass() const override {
        if (isEmpty().get()) return IList::_GetTypeclass(); 
        TSharedPtr<Typeclass> out = MakeShared();
        *out = IEither::Instances;
        const Typeclass* inner = _head.getTypeclass();
        if (!inner->Ordinal) out->Ordinal = NULL;
        if (!inner->Eq) out->Eq = NULL;
        if (!inner->Show) out->Show = NULL;
        return out;
	}
public:
	virtual ~List() = default;
    List(){};
    List(A InHead, List<A> InRest)
        : _head(InHead)
        , _rest(InRest)
    {};
    List(A seed, Arr<A, A> InNext)
        : _head(seed)
        , _next(InNext)
    {};
public:
    Bool isEmpty() { return !_head.Valid(); }
    Bool isInfinite() { return _next.Valid(); }
    A head(A fallback) {
        return isEmpty() ? fallback : _head.ResolveToUnsafe<A>();
	}
    List<A> rest() {
        if (_rest.Valid()) return _rest.ResolveToUnsafe<List<A>>();
        if (!_next.Valid()) return List();
        return List(_next(_head), _next);
    }
	List(const ListV* other);
};
template <>
class List<VStar> : public virtual IList {
private:
    VStar _head;
    VStar _rest;
    VStar _next;
	friend IList::Ordinal;
	friend IList::Show;
	friend IList::Functor;
	friend IList::Applicative;
	friend IList::Monad;
	friend IList::Semigroup;
	friend IList::Foldable;
	friend IList::Traversable;
	friend ListV;
	template <typename A>
	friend List<A>::List(const ListV* other);
public:
	virtual ~List() = default;
    List(){};
    List(VStar InHead, ListV InRest)
        : _head(InHead)
        , _rest(InRest)
    {};
    List(VStar seed, Arr<A, A> InNext)
        : _head(seed)
        , _next(InNext)
    {};
public:
    Bool isEmpty() { return !_head.Valid(); }
    Bool isInfinite() { return _next.Valid(); }
    template <typename A>
    A head(A fallback) {
        return isEmpty() ? fallback : _head.ResolveToUnsafe<A>();
	}
    template <>
    VStar head(VStar fallback) {
        return isEmpty() ? fallback : _head;
	}
    template <typename A>
    List<A> rest() {
        if (_rest.Valid()) return _rest.ResolveToUnsafe<List<A>>();
        if (!_next.Valid()) return List();
        return List(_next(_head), _next);
    }
    template <>
    ListV rest() {
        if (_rest.Valid()) return _rest.ResolveToUnsafe<ListV>();
        if (!_next.Valid()) return ListV();
        return ListV(_next(_head), _next);
    }
	List(const ListV* other);
};
template <typename A>
List<A>::List(const ListV* other) {
    _head = other->_head;
    _rest = other->_rest;
    _next = other->_next;
}
template <typename A>
auto isEmpty = curry([](List<A> l_a) -> Bool {
    return l_a.isEmpty();
});
template <typename A>
auto isInfinite = curry([](List<A> l_a) -> Bool {
    return l_a.isInfinite();
});
template <typename A>
auto head = curry([](List<A> l_a, A a) -> A {
    return l_a.head(a);
});
template <typename A>
auto rest = curry([](List<A> l_a, A a) -> A {
    return l_a.rest(a);
});
template <typename A>
auto cons = curry([](A head, List<A> list) {
    return List<A>(head, list);
});
inline FString IList::Show::_show(const VStar& a) const {
	ListV m_a = a.ResolveToUnsafe<ListV>();
	return m_a.isEmpty()
		? FString(TEXT("[]"));
        : FString::Format(TEXT("[{0}, ...]"), { m_a._head.getTypeclass()->Show->show()(m_a._head) });
}
inline ORD IList::Ordinal::_ord( const VStar& a, const VStar& b) const {
	ListV _a = a.ResolveToUnsafe<ListV>();
	ListV _b = b.ResolveToUnsafe<ListV>();
    int _ae = _a.isEmpty().get();
    int _be = _b.isEmpty().get();
    if (_ae || _be) return ORD(_be - _ae);
    ORD order = _a.head({}).getTypeclass()->Ordinal->ord()(_a.head({}))(_b.head({}));
    return order != ORD::EQ ? order : ord()(_a.rest())(_b.rest());
}
inline VStar IList::Functor::_fmap(const VStar& f, const VStar& f_a) const {
	ListV l_a = f_a.ResolveToUnsafe<ListV>();
    if (l_a.isEmpty().get()) return ListV();
	ArrV g = f.ResolveToUnsafe<ArrV>();
    return ListV(g(l_a._head), fmap()(f)(l_a.rest()));
}
inline VStar IList::Applicative::_pure(const VStar& value) const {
    return ListV(value, ListV());
}	
inline VStar IList::Applicative::_apply(const VStar& boxedFunc, const VStar& app) const {
	ListV m_a = boxedFunc.ResolveToUnsafe<ListV>();
	ListV _app = _app.ResolveToUnsafe<ListV>();
	if (m_a.isEmpty().get() || _app.isEmpty().get()) return m_a;
    return boxedFunc.getTypeclass()->Semigroup->mappend()
        (fmap()(m_a._head)(app))    
        (apply()(m_a.rest())(app)); 
}
inline  VStar IList::Monad::_bind(const VStar& m_a, const VStar& a_to_mb) const {
	ListV _ma = m_a.ResolveToUnsafe<ListV>();
	if (_ma.isEmpty().get()) return _ma;
	ArrV arr = a_to_mb.ResolveToUnsafe<ArrV>();
    return boxedFunc.getTypeclass()->Semigroup->mappend()
        (arr(m_a._head))    
        (bind()(m_a.rest())(a_to_mb)); 
}
inline VStar IList::Foldable::_foldr(const VStar& f, const VStar& initial, const VStar& foldable) const {
    ListV _ma = foldable.ResolveToUnsafe<ListV>();
    if (_ma.isEmpty()) return initial;
	ArrV g = f.ResolveToUnsafe<ArrV>();
    return g(_ma._head)(foldr()(f)(initial)(_ma.rest()));
}
inline VStar IList::Traversable::_traverse( const Typeclass* applic, const VStar& f, const VStar& foldable) const {
    ListV _ma = foldable.ResolveToUnsafe<ListV>();
	ArrV g = f.ResolveToUnsafe<ArrV>();
    ArrV cons_f = curry([](const VStar& x, const VStar& ys) {
        return applic->Applicative->liftA2()(cons)(g(x))(ys);
    });
    return foldr()(cons_f)(applic->Applicative->pure()(ListV()))(_ma);
}
inline VStar IList::Semigroup::_mappend( const VStar& left, const VStar& right) const {
    ListV _ma = left.ResolveToUnsafe<ListV>();
    if (_ma.isEmpty()) return right;
    return cons(_ma._head)(mappend()(_ma.rest())(right));
}
inline VStar IList::Monoid::_mempty() const {
    return ListV();
}
