// ---------------------------------------------------------------------------------------
// This File (Maybe_gen.h) is automatically generated by Preprocess.tt using T4 Text Transformer
// ANY changes made to this file directly are liable to be overwritten on compile
// If this file needs to be edited, Types.tt will need to be extended in its functionality
// ---------------------------- Start AutoGenerated File ---------------------------------
#pragma once
#include "Types\FDecl.h"
#include "Misc/Optional.h"
#include "Types\Typeclass\Functor.h"
#include "Types\Typeclass\Applicative.h"
#include "Types\Typeclass\Monad.h"
#include "Types\Typeclass\Semigroup.h"
#include "Types\Typeclass\Monoid.h"
#include "Types\Typeclass\Foldable.h"
#include "Types\Typeclass\Traversable.h"
#include "Types\Typeclass\Alternative.h"
#include "Types\Typeclass\Eq.h"
#include "Types\Typeclass\Ordinal.h"
#include "Types\Typeclass\Show.h"
#include "Types\Typeclass\Read.h"

 /*Added Typeclass Functor Instance Maybe*/ 
 ;

 /*Added Typeclass Applicative Instance Maybe*/ 
 ;

 /*Added Typeclass Monad Instance Maybe*/ 
 ;

 /*Added Typeclass Foldable Instance Maybe*/ 
 ;

 /*Added Typeclass Traversable Instance Maybe*/ 
 ;

 /*Added Typeclass Alternative Instance Maybe*/ 
 ;

 /*Added Typeclass Semigroup Instance Maybe*/ 
 ;

 /*Added Typeclass Monoid Instance Maybe*/ 
 ;

 /*Added Typeclass Eq Instance Maybe*/ 
 ;

 /*Added Typeclass Ordinal Instance Maybe*/ 
 ;

 /*Added Typeclass Show Instance Maybe*/ 
 ;

 /*Added Typeclass Read Instance Maybe*/ 
 ;
class IMaybe : public virtual ITypeclass {
private:
	virtual TSharedPtr<const Typeclass> _GetTypeclass() const override {
		return NoopPtr(&Instances);
	}
public:
	
 class Functor : public virtual IFunctor { 
 private: 
 virtual VStar _fmap(const VStar& f, const VStar& f_a) const override; 
 public: 
 Functor() = default; 
 }; 
 inline static const Functor FunctorInst = {}; ;
	
 class Applicative : public virtual IApplicative, public virtual Functor { 
 private: 
 virtual VStar _pure(const VStar& value) const override; 
 virtual VStar _apply(const VStar& boxedFunc, const VStar& app) const override; 
 public: 
 Applicative() = default; 
 }; 
 inline static const Applicative ApplicativeInst = {}; ;
	
 class Monad : public virtual IMonad, public virtual Applicative { 
 private: 
 virtual VStar _bind(const VStar& m_a, const VStar& a_to_mb) const override; 
 public: 
 Monad() = default; 
 }; 
 inline static const Monad MonadInst = {}; ;
	
 class Foldable : public virtual IFoldable { 
 private: 
 virtual VStar _foldr(const VStar& f, const VStar& initial, const VStar& foldable) const override; 
 public: 
 Foldable() = default; 
 }; 
 inline static const Foldable FoldableInst = {}; ;
	
 class Traversable : public virtual ITraversable, public virtual Foldable, public virtual Functor { 
 private: 
 virtual VStar _traverse(const VStar& applic, const VStar& f, const VStar& foldable) const override; 
 public: 
 Traversable() = default; 
 }; 
 inline static const Traversable TraversableInst = {}; ;
	
 class Semigroup : public virtual ISemigroup { 
 private: 
 virtual VStar _mappend( const VStar& left, const VStar& right) const override; 
 public: 
 Semigroup() = default; 
 }; 
 inline static const Semigroup SemigroupInst = {}; ;
	
 class Monoid : public virtual IMonoid, public virtual Semigroup { 
 private: 
 virtual VStar _mempty() const override; 
 public: 
 Monoid() = default; 
 }; 
 inline static const Monoid MonoidInst = {}; ;
	
 class Ordinal : public virtual IOrdinal { 
 private: 
 virtual ORD _ord( const VStar& a, const VStar& b) const override; 
 public: 
 Ordinal() = default; 
 }; 
 inline static const Ordinal OrdinalInst = {}; ;
	
 class Show : public virtual IShow { 
 private: 
 virtual FString _show( const VStar& me) const override; 
 public: 
 Show() = default; 
 }; 
 inline static const Show ShowInst = {}; ;
public:
	static const inline Typeclass Instances = []{ Typeclass ${}; $.Functor = &IMaybe::FunctorInst; $.Applicative = &IMaybe::ApplicativeInst; $.Monad = &IMaybe::MonadInst; $.Foldable = &IMaybe::FoldableInst; $.Traversable = &IMaybe::TraversableInst; $.Semigroup = &IMaybe::SemigroupInst; $.Monoid = &IMaybe::MonoidInst; $.Ordinal = &IMaybe::OrdinalInst; $.Eq = &IMaybe::OrdinalInst; $.Show = &IMaybe::ShowInst;; return $; }()
;
};
template <typename A>
class Maybe : public virtual IMaybe {
private:
	bool _isNothing;
	TOptional<A> _value;
	Maybe() {
		_isNothing = true;
	}
	Maybe(A a) {
		_isNothing = false;
		_value = a;
	}
	friend IMaybe::Functor;
	friend IMaybe::Show;
	friend IMaybe::Ordinal;
	friend class ::Functor<Maybe<A>>;
	friend MaybeV;
	virtual TSharedPtr<const Typeclass> _GetTypeclass() const override {
        if (_isNothing) return IMaybe::_GetTypeclass();
        TSharedPtr<Typeclass> out = MakeShareable(new Typeclass());
        *out = IEither::Instances;
        const Typeclass* inner = _value.getTypeclass();
        if (!inner->Semigroup) out->Semigroup = NULL;
        if (!inner->Monoid) out->Monoid = NULL;
        if (!inner->Ordinal) out->Ordinal = NULL;
        if (!inner->Eq) out->Eq = NULL;
        if (!inner->Show) out->Show = NULL;
        return out;
	}
public:
	virtual ~Maybe() = default;
	static Maybe<A> Just(A a) {
		return Maybe<A>(a);
	}
	static Maybe<A> Nothing() {
		return Maybe<A>();
	}
public:
	A fromMaybe(A fallback) {
		if (_isNothing) {
			return fallback;
		} else {
			return _value.GetValue();
		}
	}
	Maybe(const MaybeV* other);
};
template <>
class Maybe<VStar> : public virtual IMaybe {
private:
	friend VStar;
	friend Maybe;
	friend class ATypeRepr;
	friend IMaybe::Ordinal;
	friend IMaybe::Show;
	friend IMaybe::Functor;
	friend IMaybe::Applicative;
	friend IMaybe::Monad;
	friend IMaybe::Monoid;
	friend IMaybe::Semigroup;
	friend IMaybe::Foldable;
	friend IMaybe::Traversable;
	template <typename A>
	friend Maybe<A>::Maybe(const MaybeV* other);
	bool _isNothing;
	VStar _value;
	Maybe() {
		_isNothing = true;
	}
	Maybe(VStar from) {
		_isNothing = false;
		_value = from;
	}
	friend class ::Functor<MaybeV>;
public:
	virtual ~Maybe() = default;
	template <typename A>
	static MaybeV Just(A a) {
		return MaybeV(VStar(a));
	}
	template <>
	static MaybeV Just(VStar a) {
		return MaybeV(a);
	}
	static MaybeV Nothing() {
		return MaybeV();
	}
public:
	template <typename A>
	A fromMaybe(A fallback) {
		if (_isNothing) {
			return fallback;
		} else {
			return _value.ResolveToUnsafe<A>();
		}
	}
	template <>
	VStar fromMaybe(VStar fallback) {
		if (_isNothing) {
			return fallback;
		} else {
			return _value;
		}
	}
};
template <typename A>
Maybe<A>::Maybe(const MaybeV* other) {
	_isNothing = other->_isNothing;
	if (!_isNothing) {
		_value = other->_value.ResolveToUnsafe<A>();
	}
}
template <typename A>
auto fromMaybe = curry([](A a, Maybe<A> m_a) -> A {
	return m_a.fromMaybe(a);
});
inline VStar IMaybe::Functor::_fmap(const VStar& f, const VStar& f_a) const {
	ArrV g = f.ResolveToUnsafe<ArrV>();
	MaybeV m_a = f_a.ResolveToUnsafe<MaybeV>();
	if (m_a._isNothing) {
		return VStar(MaybeV::Nothing());
	} else {
		VStar result = g(m_a._value);
		return VStar(MaybeV::Just(result));
	}
}
inline VStar IMaybe::Applicative::_pure(const VStar& value) const {
	return MaybeV::Just(value);
}	
inline VStar IMaybe::Applicative::_apply(const VStar& boxedFunc, const VStar& app) const {
	MaybeV m_a = boxedFunc.ResolveToUnsafe<MaybeV>();
	if (m_a._isNothing) return MaybeV::Nothing();
	return app.getTypeclass()->Functor->fmap()(m_a._value)(app);
}
inline  VStar IMaybe::Monad::_bind(const VStar& m_a, const VStar& a_to_mb) const {
	MaybeV _ma = m_a.ResolveToUnsafe<MaybeV>();
	if (_ma._isNothing) return MaybeV::Nothing();
	ArrV arr = a_to_mb.ResolveToUnsafe<ArrV>();
	return arr(_ma._value);
}
inline FString IMaybe::Show::_show(const VStar& a) const {
	MaybeV m_a = a.ResolveToUnsafe<MaybeV>();
	if (m_a._isNothing) {
		return FString(TEXT("Nothing"));
	} else {
		FString inner = m_a._value.getTypeclass()->Show->show()(m_a._value);
		return FString(TEXT("Just ")) + inner;
	}
}
inline ORD IMaybe::Ordinal::_ord( const VStar& a, const VStar& b) const {
	MaybeV _a = a.ResolveToUnsafe<MaybeV>();
	MaybeV _b = b.ResolveToUnsafe<MaybeV>();
	if (_a._isNothing || _b._isNothing) return ORD(_b._isNothing - _a._isNothing);
	return _a._value.getTypeclass()->Ordinal->ord()(_a._value)(_b._value);
}
inline VStar IMaybe::Foldable::_foldr(const VStar& f, const VStar& initial, const VStar& foldable) const {
    MaybeV _ma = foldable.ResolveToUnsafe<MaybeV>();
    if (_ma._isNothing) return initial;
	ArrV g = f.ResolveToUnsafe<ArrV>();
    return g(_ma._value).ResolveToUnsafe<ArrV>()(initial);
}
inline VStar IMaybe::Traversable::_traverse( const VStar& applic, const VStar& f, const VStar& foldable) const {
    MaybeV _ma = foldable.ResolveToUnsafe<MaybeV>();
    if (_ma._isNothing) {
        return applic.getTypeclass()->Applicative->pure()(MaybeV::Nothing());
    }
	ArrV g = f.ResolveToUnsafe<ArrV>();
	VStar h = VStar(curry([](const VStar& x) { return MaybeV::Just(x); }));
    return _ma._value.getTypeclass()->Functor->fmap()(h)(g(_ma._value));
}
inline VStar IMaybe::Semigroup::_mappend( const VStar& left, const VStar& right) const {
    MaybeV ma = left.ResolveToUnsafe<MaybeV>();
    MaybeV mb = left.ResolveToUnsafe<MaybeV>();
    if (ma._isNothing) return mb;
	if (mb._isNothing) return ma;
	return MaybeV::Just(ma._value.getTypeclass()->Semigroup->mappend()(ma._value)(mb._value));
}
inline VStar IMaybe::Monoid::_mempty() const {
    return MaybeV::Nothing();
}
